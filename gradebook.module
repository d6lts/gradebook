<?php

// hook_help
function gradebook_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      // This description is shown in the listing at admin/modules.
      return t('Provides a site-wide gradebook.');
  }
}

// hook_perm
function gradebook_perm() {
  return array('view gradebook', 'view own gradebook', 'edit gradebook');
}

// hook_menu
function gradebook_menu($may_cache) {
  $items = array();
  
  // The $may_cache parameter is used to divide menu items into two parts. Those
  // returned when $may_cache is true must be consistently applicable for the
  // current user at all times; the others may change or be defined at only
  // certain paths. Most modules will have excusively cacheable menu items.
  if ($may_cache) {
    $items[] = array(
      'path'      =>  'gradebook',
      'title'    =>  t('gradebook'),
      'access' => user_access('view gradebook')||user_access('view own gradebook'),
      'callback'  => 'gradebook_page',
    );
    $items[] = array(
      'path' => 'gradebook/view',
      'title' => t('view'),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -10,
    ); 
    $items[] = array(
      'path'      =>  'gradebook/category',
      'title'    =>  t('categories'),
      'access' => user_access('edit gradebook'),
      'callback'  => 'gradebook_category_page',
      'type'  => MENU_LOCAL_TASK,
    );
    // TODO: why is this tab not showing?
    $items[] = array(
      'path'      =>  'gradebook/category/add',
      'title'    =>  t('add category'),
      'access' => user_access('edit gradebook'),
      'callback'  => 'gradebook_category_form',
      'type' => MENU_LOCAL_TASK,
    );
  }
  elseif (is_numeric(arg(2)) && is_numeric(arg(3))) {
    $grade = gradebook_get_grade(arg(2), arg(3));
    $items[] = array(
      'path' => 'gradebook/grade',
      'title' => t('edit grade'),
      'callback' => 'gradebook_grade_form',
      'callback arguments' => array((array)$grade),
      'access' => user_access('edit gradebook'),
      'type' => MENU_CALLBACK,
    );
  }
  elseif (is_numeric(arg(3))) {
    $term = taxonomy_get_term(arg(3));
    // Check if this is a valid term.
    if ($term) {
      $items[] = array(
        'path' => 'gradebook/category/edit',
        'title' => t('edit category'),
        'callback' => 'gradebook_category_form',
        'callback arguments' => array((array)$term),
        'access' => user_access('edit gradebook'),
        'type' => MENU_CALLBACK,
      );
    }
  } 
  
  return $items;
}

// hook_settings
// TODO: break out hard coded settings
function gradebook_settings() {
  $form = array();
  
  $roles = user_roles();
  unset($roles[DRUPAL_ANONYMOUS_RID]);
  
  $sel_roles = (array) variable_get('gradebook_student_rids', array());
  $default = array();
  foreach ($sel_roles as $rid => $value) {
    if ($value) {
      $default[] = $rid;
    }
  }
  $form['gradebook_student_rids'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Student roles'),
    '#default_value' => $default,
    '#options' => $roles,
    '#description' =>  t('Check at least one role.'),
    '#required' => TRUE,
  );
  
  $sel_roles = (array) variable_get('gradebook_teacher_rids', array());
  $default = array();
  foreach ($sel_roles as $rid => $value) {
    if ($value) {
      $default[] = $rid;
    }
  }
  $form['gradebook_teacher_rids'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Teacher roles'),
    '#default_value' => $default,
    '#options' => $roles,
    '#description' =>  t('Check at least one role.'),
    '#required' => TRUE,
  );
  
  return $form;
}

function gradebook_page() {
  global $user;
  
  $vid = _gradebook_get_vid();
  $tree = taxonomy_get_tree($vid);
  $tids = array_map('_taxonomy_get_tid_from_term', $tree);
  $nodes = array();
  $header = array('');
  $rows = array();
  
  // taxonomy_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC')
  $result = taxonomy_select_nodes($tids, 'or', 0, FALSE, 'n.created ASC');
  while ($node = db_fetch_object($result)) {
    $node = node_load($node->nid);
    $nodes[] = $node;
    $header[] = l($node->title, 'node/'.$node->nid) . '<br />' . $node->possible;
  }
  $header[] = ''; // total grade

  // TODO: how should we render categories?
  if (user_access('view gradebook')) {
    //$result = db_query("SELECT uid, name FROM {users} WHERE uid > 1 AND status != 0 ORDER BY name ASC");
    $str_rids = implode(',', array_keys(_gradebook_student_roles()));
    $result = db_query("SELECT u.uid, u.name FROM {users} u INNER JOIN {users_roles} r ON u.uid = r.uid WHERE u.status != 0 AND r.rid IN (". $str_rids .") ORDER BY u.name ASC");
  }
  else {
    $result = db_query("SELECT uid, name FROM {users} WHERE uid=%d", $user->uid);
  }
  while ($account = db_fetch_object($result)) {
    $row = array();
    $row[] = theme('username', $account);
    foreach ($nodes as $node) {
      $grade = gradebook_get_grade($account->uid, $node->nid);
      $row[] = l(($grade->earned?$grade->earned:'-'), 'gradebook/grade/'.$account->uid.'/'.$node->nid);
    }
    $grade = _gradebook_get_total_grade($account->uid);
    $row[] = $grade->earned . '/' . $grade->possible;
    $rows[] = $row;
  }
  
  return theme('table', $header, $rows);
}

function gradebook_category_page() {
  // TODO: code borrowed from forum.module
  //       needs serious cleanup
  $vid = _gradebook_get_vid();
  $destination = drupal_get_destination();

  $header = array(t('Name'), t('Operations'));
  $vocabulary = taxonomy_get_vocabulary($vid);

  drupal_set_title(check_plain($vocabulary->name));
  $start_from      = $_GET['page'] ? $_GET['page'] : 0;
  $total_entries   = 0;  // total count for pager
  $page_increment  = 25; // number of tids per page
  $displayed_count = 0;  // number of tids shown

  $tree = taxonomy_get_tree($vocabulary->vid);
  foreach ($tree as $term) {
    $total_entries++; // we're counting all-totals, not displayed
    if (($start_from && ($start_from * $page_increment) >= $total_entries) || ($displayed_count == $page_increment)) { continue; }
    $rows[] = array(_taxonomy_depth($term->depth) . ' ' . l($term->name, "gradebook/category/edit/$term->tid"), l(t('edit'), "gradebook/category/edit/$term->tid", array(), $destination));
    $displayed_count++; // we're counting tids displayed
  }

  if (!$rows) {
    $rows[] = array(array('data' => t('No categories available.'), 'colspan' => '2'));
  }

  $GLOBALS['pager_page_array'][] = $start_from;  // FIXME
  $GLOBALS['pager_total'][] = intval($total_entries / $page_increment) + 1; // FIXME

  if ($total_entries >= $page_increment) {
    $rows[] = array(array('data' => theme('pager', NULL, $page_increment), 'colspan' => '2'));
  }

  return theme('table', $header, $rows, array('id' => 'taxonomy'));
}

function gradebook_category_form($edit = array()) {
  // Handle a delete operation.
  if ($_POST['op'] == t('Delete') || $_POST['edit']['confirm']) {
    return _gradebook_confirm_delete($edit['tid']);
  }
  
  $form['name'] = array(
    '#title' => t('Category name'),
    '#type' => 'textfield',
    '#default_value' => $edit['name'],
    '#maxlength' =>  64,
    '#description' => t('The category name is used to identify related assignments.'),
    '#required' => TRUE
  );

  $form['description'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#default_value' => $edit['description'],
    '#description' => t('The category description can give users more information about the assignments it contains.')
  );
  $form['parent']['#tree'] = TRUE;
  $form['parent'][0] = _gradebook_parent_select($edit['tid'], t('Parent'));
  $form['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Weight'),
    '#default_value' => $edit['weight'],
    '#description' => t('When listing categories, those with with light (small) weights get listed before containers with heavier (larger) weights. Categories with equal weights are sorted alphabetically.')
  );

  $form['vid'] = array(
    '#type' => 'hidden',
    '#value' => _gradebook_get_vid(),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );
  if ($edit['tid']) {
    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));
    $form['tid'] = array('#type' => 'value', '#value' => $edit['tid']);
  }

  return drupal_get_form('gradebook_category_form', $form, 'gradebook_form');
}

function gradebook_category_form_submit($form_id, $form_values) {
  $status = taxonomy_save_term($form_values);
  switch ($status) {
    case SAVED_NEW:
      drupal_set_message(t('Created new %type %term.', array('%term' => theme('placeholder', $form_values['name']), '%type' => t('category'))));
      break;
    case SAVED_UPDATED:
      drupal_set_message(t('The %type %term has been updated.', array('%term' => theme('placeholder', $form_values['name']), '%type' => t('category'))));
      break;
  }
  return 'gradebook/category'; 
}

function gradebook_grade_form($edit = array()) {
  $account = user_load(array('uid' => $edit['uid']));
  $node = node_load($edit['nid']);

  // TODO: cleanup grade form rendering
  //       ideally edit is in place in gradebook using AJAX
  $form['user'] = array(
    '#value' => 'Student: ' . $account->name . "<br />\n",
  );
  
  $form['node'] = array(
    '#value' => 'Assignment: ' . $node->title . "<br />\n",
  );
  
  $form['possible'] = array(
    '#value' => 'Possible: ' . $node->possible . "<br />\n",
  );

  $form['overage'] = array(
    '#value' => 'Overage: ' . ($node->overage?'Yes':'No') . "<br />\n",
  );
  
  $form['earned'] = array(
    '#title' => t('Earned'),
    '#type' => 'textfield',
    '#default_value' => $edit['earned'],
    '#maxlength' =>  64,
    '#description' => t('The greade earned.'),
    '#required' => TRUE
  );

  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $edit['uid'],
  );
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $edit['nid'],
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  return drupal_get_form('gradebook_grade_form', $form, 'gradebook_form');
}

function gradebook_grade_form_validate($form_id, $form_values) {
  $account = user_load(array('uid' => $form_values['uid']));
  $node = node_load($form_values['nid']);
  
  if (!$account || !$node) {
    form_set_error('', t('The UID/NID has an error.'));
  }

  if (!$node->overage) {
    if ($form_values['earned'] > $node->possible) {
      form_set_error('earned', t('You can not enter a value over the possible value for this assignment.'));
    }
  }
}

function gradebook_grade_form_submit($form_id, $form_values) {
  gradebook_set_grade((object)$form_values);
  drupal_set_message(t('Saved %type.', array('%type' => t('grade'))));
  return 'gradebook'; 
}

// hook_taxonomy
function gradebook_taxonomy($op, $type, $term = NULL) {
  if ($op == 'delete' && $term['vid'] == _gradebook_get_vid()) {
    switch ($type) {
      // TODO: what do we need from this?
      //       code borrowed from forum.module and needs cleanup
      /*
      case 'term':
        $results = db_query('SELECT f.nid FROM {forum} f WHERE f.tid = %d', $term['tid']);
        while ($node = db_fetch_object($results)) {
          // node_delete will also remove any association with non-forum vocabularies.
          node_delete($node->nid);
        }

        // For containers, remove the tid from the forum_containers variable.
        $containers = variable_get('forum_containers', array());
        $key = array_search($term['tid'], $containers);
        if ($key !== FALSE) {
          unset($containers[$key]);
        }
        variable_set('forum_containers', $containers);
        break;
      */
      case 'vocabulary':
        variable_del('gradebook_nav_vocabulary');
    }
  }
}

function gradebook_assignment_form_elements($node) {
  $form = array();
  
  $form['possible'] = array(
    '#type' => 'textfield',
    '#title' => t('Possible'),
    '#default_value' => ($node->possible?$node->possible:'0'),
    '#size' => 10,
    '#maxlength' => 10,
    '#required' => TRUE,
  );
  
  $form['overage'] = array(
    '#type' => 'checkbox',
    '#title' => t('Overage'),
    '#default_value' => ($node->overage?$node->overage:'0'),
  );
  
  return $form;
}

function gradebook_assignment_validate(&$node) {
  if (!is_numeric($node->possible) || ($node->possible < 0)) {
    form_set_error('possible', t('The possible value for the assignment must be a positive integer.')); 
  }
}

function gradebook_assignment_submit(&$node) {
  // TODO: anything to do here?
}

function gradebook_assignment_load($node) {
  $additions = db_fetch_object(db_query('SELECT possible, overage FROM {gradebook_assignment} WHERE nid = %d', $node->nid));
  return $additions;
} 

function gradebook_assignment_insert($node) {
  db_query("INSERT INTO {gradebook_assignment} (nid, possible, overage) VALUES (%d, %d, %d)", $node->nid, $node->possible, $node->overage);
  
  $terms = taxonomy_node_get_terms_by_vocabulary($node->nid, _gradebook_get_vid());
  foreach ($terms as $term) {
    _gradebook_calc_grades(0, $term->tid);
  }
}

function gradebook_assignment_update($node) {
  db_query("UPDATE {gradebook_assignment} SET possible = '%s', overage = %d WHERE nid = %d", $node->possible, $node->overage, $node->nid);
  
  $terms = taxonomy_node_get_terms_by_vocabulary($node->nid, _gradebook_get_vid());
  foreach ($terms as $term) {
    _gradebook_calc_grades(0, $term->tid);
  }
}

function gradebook_assignment_delete($node) {
  // Notice that we're matching all revision, by using the node's nid.
  db_query('DELETE FROM {gradebook_assignment} WHERE nid = %d', $node->nid);
  // TODO: delete grades
}

function gradebook_get_grade($uid, $nid) {
  // try to get grade data
  $result = db_query(
    'SELECT g.earned, g.timestamp '.
    'FROM {gradebook_grade} g '.
    'WHERE g.uid=%d AND g.nid=%d', $uid, $nid);
  $grade = db_fetch_object($result);
  
  // add 'possible' grade
  $result = db_query(
    'SELECT a.possible '.
    'FROM {gradebook_assignment} a '.
    'WHERE a.nid=%d', $nid);
  if ($assignment = db_fetch_object($result)) {
    $grade->possible = $assignment->possible;
  }
  
  // add uid/nid
  $grade->uid = $uid;
  $grade->nid = $nid;
  
  return $grade;
}

function gradebook_set_grade($grade) {
  $old = gradebook_get_grade($grade->uid, $grade->nid);
  $grade->timestamp = time();
  if ($old->timestamp) {
    db_query('UPDATE {gradebook_grade} SET earned=%d, timestamp=%d WHERE uid=%d AND nid=%d', $grade->earned, $grade->timestamp, $grade->uid, $grade->nid);
  }
  else {
    db_query("INSERT INTO {gradebook_grade} (uid, nid, earned, timestamp) VALUES (%d, %d, %d, %d)", $grade->uid, $grade->nid, $grade->earned, $grade->timestamp); 
  }
  
  $terms = taxonomy_node_get_terms_by_vocabulary($grade->nid, _gradebook_get_vid());
  foreach ($terms as $term) {
    _gradebook_calc_grades($grade->uid, $term->tid);
  }
}

function _gradebook_get_vid() {
  $vid = variable_get('gradebook_nav_vocabulary', '');
  if (empty($vid)) {
    // Check to see if a forum vocabulary exists
    $vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE module = '%s'", 'gradebook'));
    if (!$vid) {
      $edit = array(
        'name' => 'Gradebook',
        'multiple' => 0,
        'required' => 1,
        'hierarchy' => 1,
        'relations' => 0,
        'module' => 'gradebook',
        'nodes' => array('assignment' => 1)
      );
      taxonomy_save_vocabulary($edit);
      $vid = $edit['vid'];
      
      $edit = array(
        'name' => 'uncategorized',
        'description' => '',
        'vid' => $vid,
        'weight' => 0
      );
      taxonomy_save_term($edit);
    }
    variable_set('gradebook_nav_vocabulary', $vid);
  }

  return $vid;
}

function _gradebook_parent_select($tid, $title) {
  $parents = taxonomy_get_parents($tid);
  if ($parents) {
    $parent = array_shift($parents);
    $parent = $parent->tid;
  }
  else {
    $parent = 0;
  }

  $children = taxonomy_get_tree(_gradebook_get_vid(), $tid);

  // A term can't be the child of itself, nor of its children.
  foreach ($children as $child) {
    $exclude[] = $child->tid;
  }
  $exclude[] = $tid;

  $tree = taxonomy_get_tree(_gradebook_get_vid());
  $options[0] = '<'. t('root') .'>';
  if ($tree) {
    foreach ($tree as $term) {
      if (!in_array($term->tid, $exclude)) {
        $options[$term->tid] = _taxonomy_depth($term->depth) . $term->name;
      }
    }
  }

  return array('#type' => 'select', '#title' => $title, '#default_value' => $parent, '#options' => $options, '#description' => $description, '#required' => TRUE);
}

function _gradebook_confirm_delete($tid) {
  // TODO: handle term deletion
  //       see forum.module code
}

function _gradebook_student_roles() {
  $roles = user_roles();
  unset($roles[DRUPAL_ANONYMOUS_RID]);
  unset($roles[DRUPAL_AUTHENTICATED_RID]);
  
  $sel_roles = (array) variable_get('gradebook_student_rids', array());
  foreach ($sel_roles as $rid => $value) {
    if (!$value) {
      unset($roles[$rid]);
    }
  }
  
  return $roles;
}

function _gradebook_teacher_roles() {
  $roles = user_roles();
  unset($roles[DRUPAL_ANONYMOUS_RID]);
  unset($roles[DRUPAL_AUTHENTICATED_RID]);
  
  $sel_roles = (array) variable_get('gradebook_teacher_rids', array());
  foreach ($sel_roles as $rid => $value) {
    if (!$value) {
      unset($roles[$rid]);
    }
  }
  
  return $roles;
}

function _gradebook_calc_grades($uid, $tid) {
  $earned = 0;
  $possible = 0;
  
  // if UID is < 1, calc grades for ALL users
  if (!$uid) {
    return _gradebook_calc_grades_all_users($tid);
  }
  
  // clear cache
  db_query("DELETE FROM {gradebook_cache} WHERE tid=%d AND uid=%d", $tid, $uid); 
  
  // get grades from child terms
  $children = taxonomy_get_children($tid, _gradebook_get_vid());
  foreach ($children as $child) {
    $grade = _gradebook_get_term_grade($uid, $child->tid);
    if ($grade) {
      $earned += $grade->earned;
      $possible += $grade->possible;
    }
  }
  
  // get grades from nodes at this term
  $result = taxonomy_select_nodes(array($tid), 'or', 0, FALSE);
  while ($node = db_fetch_object($result)) {
    $grade = gradebook_get_grade($uid, $node->nid);
    if ($grade) {
      $earned += $grade->earned;
      $possible += $grade->possible;
    }
  }
  
  // cache grade
  db_query("INSERT INTO {gradebook_cache} (uid, tid, earned, possible) VALUES (%d, %d, %d, %d)", $uid, $tid, $grade->earned, $grade->possible); 
  
  // recalc parents
  $parents = taxonomy_get_parents($tid);
  foreach ($parents as $parent) {
    _gradebook_calc_grades($uid, $parent->tid);
  }
}

function _gradebook_calc_grades_all_users($tid) {
  $str_rids = implode(',', array_keys(_gradebook_student_roles()));
  $result = db_query("SELECT u.uid, u.name FROM {users} u INNER JOIN {users_roles} r ON u.uid = r.uid WHERE u.status != 0 AND r.rid IN (". $str_rids .") ORDER BY u.name ASC");
  while ($account = db_fetch_object($result)) {
    _gradebook_calc_grades($account->uid, $tid);
  }
}

function _gradebook_get_term_grade($uid, $tid) {
  $result = db_query("SELECT earned, possible FROM {gradebook_cache} WHERE tid=%d AND uid=%d", $tid, $uid);
  $grade = db_fetch_object($result);
  return $grade;
}

function _gradebook_get_total_grade($uid) {
  $total['earned'] = 0;
  $total['possible'] = 0;
  
  $terms = taxonomy_get_tree(_gradebook_get_vid(), 0, -1, 1);
  foreach ($terms as $term) {
    $grade = _gradebook_get_term_grade($uid, $term->tid);
    if ($grade) {
      $total['earned'] += $grade->earned;
      $total['possible'] += $grade->possible;
    }
  }
  
  return (object)$total;
}
