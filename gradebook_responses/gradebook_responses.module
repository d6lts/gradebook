<?php
// $Id$
/**
 * @file
 * Provides student responses to gradebook assignments.
 */

/**
 * These constants are used for the response status.
 */
define('GRADEBOOK_RESPONSES_NOT_SET', 0);
define('GRADEBOOK_RESPONSES_IN_PROGRESS', 1);
define('GRADEBOOK_RESPONSES_COMPLETED', 2);
define('GRADEBOOK_RESPONSES_GRADED', 3);
define('GRADEBOOK_RESPONSES_REDO', 4);

/**
 *  Implements hook_views_api().
 */
function gradebook_responses_views_api() {
  return array('api' => 2.0);
}

/**
 * Implements hook_theme().
 */
function gradebook_responses_theme() {
  return array(
    'gradebook_responses_notice' => array('arguments' => array('assignment', 'node')),
    'gradebook_responses_gradebook_form_title' => array('arguments' => array('nid', 'uid')),
  );
}

/**
 * Implements hook_user().
 */
function gradebook_responses_user($op, &$edit, &$account, $category = NULL) {
  if ($op == 'delete' ) {
    // Do something with gradebook responses. Parallel what is done in gradebookapi.module.
  }
}

/** 
 * Implements hook_link().
 */
function gradebook_responses_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();
  $aid = $node->nid;
  $assignment_types = gradebookapi_get_assignment_types();
  if (isset($assignment_types[$node->type]) && gradebook_responses_user_response_permitted($aid) && ($node->response_deadline == 1 || (time() < $node->due_date))) {
    $terms = gradebookapi_assignment_terms($node);
    $gids = array();
    foreach ($terms as $term) { 
      $gradebook = gradebookapi_get_tid_gradebook($term->tid);
      $gids[] = $gradebook->tid;
    }
    if (!empty($gids)) {
      $response_types = gradebook_responses_allowed_response_types($aid);
      // Allow assignment to be in multiple gradebooks.
      foreach (array_unique($gids) as $gid)  {
        $gradebook = gradebookapi_get_tid_gradebook($gid);
        $student = gradebookapi_is_student($gradebook);
        // Only students are allowed to create a response.
        if ($student) {  
          foreach ($response_types as $type) {
            $type_name = db_result(db_query("SELECT name FROM {node_type} where type = '%s'", $type));
            // Need this for content types with underscores.
            $type_url_str = str_replace('_', '-', $type);

            $links['gradebook_responses_'. $type] = array(
              'title' => t("Create a !name response.", array('!name' => $type_name)),
              'href' => 'node/add/' . $type_url_str,
              'query' => 'aid=' . $aid,
              'attributes' => array('title' => t("Create a !name response to this assignment.", array('!name' => $type_name))),
            );
          }
        }
      }
    }
  }
  return $links;
}

/**
 * Implement hook_init().
 */
function gradebook_responses_init() {
  // Add the CSS for this module.
  drupal_add_css(drupal_get_path('module', 'gradebook_responses') . '/gradebook_responses.css');
}

/**
 * Retrieves the response node types selected on the gradebookapi admin form.
 *
 * @return
 *   An array of content types.
 */
function gradebook_responses_get_response_types() {
  $types = array_filter((array) variable_get('gradebook_responses_types', array()));
  return $types;
}

/**
 * Retrieves an array of allowed response types for an assignment.
 *
 * @param $aid
 *   The node id for the assignment.
 *
 * @return
 *   An array of content types.
 */
function gradebook_responses_allowed_response_types($aid) {
  $types = array();
  $result = db_result(db_query('SELECT response_types FROM {gradebookapi_assignment} WHERE nid = %d', $aid));
  if (isset($result)) {
    $types = explode(',', $result);
  }
  return $types;
}

/**
 * Retrieves the maximum number of allowed responses for this assignment.
 *
 * @param $aid
 *   The node id for the assignment.
 *
 * @return
 *   The maximum number of responses.
 */
function gradebook_responses_assignment_max_responses($nid) {
  return db_result(db_query('SELECT max_responses FROM {gradebookapi_assignment} WHERE nid = %d', $nid));
}

/**
 * Retrieves student response node information from gradebook_responses table.
 *
 * @param $param
 *   An associative array where the keys can be 'uid', 'nid', or 'aid'.
 *   Example: To return all responses for assignment with $node->nid, use array('aid' => $node->nid).
 *
 * @return
 *   An array of the response values.
 */
function gradebook_responses_get_responses($param = array()) {
  foreach ($param as $key => $value) {
    $cond[] = db_escape_string($key) . ' = %d';
    $arguments[] = $value;
  }
  $cond = implode(' AND ', $cond);

  $result = db_query('SELECT * FROM {gradebook_responses} WHERE ' . $cond, $arguments);
  $responses = array();
  while ($response = db_fetch_array($result)) {
   $responses[] = $response;
  }
  return $responses;
}

/**
 * Determines the number of user responses for an assignment.
 *
 * @param $nid
 *   The assignment node.
 * @param $uid
 *   The user id.
 *
 * @return
 *   The number of responses for an assignment.
 */
function gradebook_responses_grade_response_number($nid, $uid = NULL) {
  if (is_null($uid)) {
    global $user;
    $uid = $user->uid;
  }
  return (int) db_result(db_query('SELECT COUNT(nid) FROM {gradebook_responses} WHERE uid = %d AND aid = %d', $uid, $nid));
}

/**
 * Determines whether the user has submitted a response for an assignment.
 *
 * @param $nid
 *   The assignment node.
 * @param $uid
 *   The user id.
 *
 * @return
 *   TRUE if a response exists, FALSE otherwise.
 */
function gradebook_responses_grade_has_response($nid, $uid = NULL) {
  $count = gradebook_responses_grade_response_number($nid, $uid);
  return ($count > 0);
}

/**
 * Determines if a user is allowed to create a response for an assignment.
 *
 * @param $aid
 *   The assignment node.
 * @param $uid
 *   The user id.
 *
 * @return
 *   TRUE if a response is allowed, FALSE otherwise.
 */
function gradebook_responses_user_response_permitted($aid, $uid = NULL) {
  $count = gradebook_responses_grade_response_number($aid, $uid);
  // Gets a count of the number of responses allowed for this assignment.
  $max = gradebook_responses_assignment_max_responses($aid);
  return (($max == 0) || ($max > $count));
}

/**
 * Retrieves additional form elements from the gradebook_responses table.
 *
 * These elements are added to the response create node form.
 *
 * @param $node
 *   The response node.
 * @return
 *   An array of form default values.
 *
 * @see gradebook_responses_nodeapi().
 */
function _gradebook_responses_load($node) {
  $additions = gradebook_responses_get_responses(array('nid' => $node->nid));
  return array_pop($additions);
}

/**
 * Inserts additional assignment fields into the gradebook_responses table.
 *
 * @param $node
 *   The assignment node.
 *
 * @return NONE
 *
 * @see gradebook_responses_nodeapi().
 */
function _gradebook_responses_insert($node) {
  if (is_numeric($node->aid)) {
    db_query("INSERT INTO {gradebook_responses} (nid, aid, uid, rstatus) VALUES (%d, %d, %d, %d)", $node->nid, $node->aid, $node->uid, $node->rstatus);
  }
}

/**
 * Updates response fields in the gradebook_responses table.
 *
 * @param $node
 *   The assignment node.
 *
 * @return NONE
 *
 * @see gradebook_responses_nodeapi().
 */
function _gradebook_responses_update(&$node) {
  if (is_numeric($node->aid)) {
    if (db_result(db_query('SELECT * FROM {gradebook_responses} a WHERE a.nid = %d AND a.uid = %d', $node->nid, $node->uid))) {
      db_query("UPDATE {gradebook_responses} SET aid = %d, rstatus = %d WHERE nid = %d AND uid = %d", $node->aid, $node->rstatus, $node->nid, $node->uid);
    }
    else {
      // The assignment doesn't exist in gradebook_responses table for this user, so insert it.
      _gradebook_responses_insert($node);
    }
  }
}

/**
 * Deletes response field values from the gradebook_responses table.
 * 
 * The grades are then recalculated.
 *
 * @param $node
 *   The assignment node.
 *
 * @return NONE
 *
 * @see gradebook_responses_nodeapi().
 */
function _gradebook_responses_delete($node) {
  // Delete records for all students for this assignment node.
  db_query('DELETE FROM {gradebook_responses} WHERE nid = %d AND uid = %d', $node->nid, $node->uid);
}

/**
 * Adds assignment response values to $node->content before rendering.
 *
 * @param $node
 *   The assignment node.
 * @param $teaser
 *   The teaser parameter passed from node_view().
 * @param $page
 *   The page parameter passed from node_view().
 *
 * @return NONE
 *
 * @see gradebook_responses_nodeapi().
 */
function _gradebook_responses_view(&$node, $teaser = FALSE, $page = FALSE) {
  // Do not modify $node->content unless an assignment id has been assigned.
  if (isset($node->aid) && is_numeric($node->aid)) {
    $assignment = node_load($node->aid);
    $node->content['response_notice'] = array(
      '#value' => theme('gradebook_responses_notice', $assignment, $node),
      '#weight' => -100,
    );
  }
}

/**
 * Returns HTML documenting assignment details.
 *
 * @param $assignment
 *   The assignment node.
 * @param $node
 *   The response node.
 *
 * @return
 *   The HTML string ready to display.
 *
 * @ingroup themeable
 */
function theme_gradebook_responses_notice($assignment, $node) {
  global $user;
  $account = user_load(array('uid' => $node->uid));
  $who = ($user->uid == $node->uid) ? t('You have') : $account->name . ' ' . t('has');

  $num_responses = gradebook_responses_grade_response_number($assignment->nid, $node->uid);

  $output = '<div class="gradebook-response-assignment">';
  $output .= '<p>';
  $output .= t('Response to Assignment') . ': ';
  $output .= '<span class = "gradebook-response-assignment-title">' . l($assignment->title, 'node/' . $assignment->nid) . '</span>';
  $status_string = _gradebook_responses_status_string();
  if ($text = $status_string[$node->rstatus]) {
    if ($node->rstatus == GRADEBOOK_RESPONSES_GRADED || $node->rstatus == GRADEBOOK_RESPONSES_REDO) {
      $terms = gradebookapi_assignment_terms($assignment);
      if (!empty($terms)) {
        $gradebook = gradebookapi_get_tid_gradebook($terms[0]->tid);
        if (($user->uid == $node->uid) || gradebookapi_is_teacher($gradebook)) {
          $grade = gradebookapi_get_grade($node->uid, $assignment->nid);
          $ret = theme('gradebook_assignment_grade', $gradebook, $grade);
          if ($node->rstatus == GRADEBOOK_RESPONSES_GRADED) {
            $text .= ' : ' . $ret['data'] . '/' . $assignment->possible;
          }
          else {
            $text = $status_string[GRADEBOOK_RESPONSES_GRADED] .'  ' . $ret['data'] . '/' . $assignment->possible;
            $text .= ' : ' . $status_string[GRADEBOOK_RESPONSES_REDO] . ' ' . t('Allowed'); 
          }
        }
      }
    }
    $output .= '<span class = "gradebook-response-status-string">' . ' (' . $text . ')' . '</span>';
  }
  $output .= '</p><p>';
  $output .= '<span class = "gradebook-response-number">';
  $output .= format_plural($num_responses, '%name created one response for this assignment',
               '%name submitted @count responses for this assignment', array('%name' => $who));
  $output .= '</span>';
  $output .= '<span class = "gradebook-response-permitted">';
  $output .= ' (';
  if ($assignment->max_responses == 0) {
    $output .= t('Unlimited');
  }
  else {
    $output .= format_plural($assignment->max_responses, 'One response is allowed', '@count responses are allowed');
  }
  $output .= ').';
  $output .= '</span></p>';
  
  $output .= '</div>';
  return $output;
}

/**
 * Assigns the status string used to describe the state of the response.
 *
 * @param $which
 *   If 'all' then the string is loaded with all possible values.
 *   Otherwise, only values appropriate for students are included.
 *
 * @return $status_string
 *   An array of localized strings indicating the status of the response.
 *   The numeric keys of this array correspond to the rstatus field in the
 *   in the gradebook_responses table.
 */
function _gradebook_responses_status_string($which = 'all') {
  static $status_string;
  if (empty($status_string)) {
    $status_string = array(
      GRADEBOOK_RESPONSES_NOT_SET     => '- ' . t('Not set') . ' -',
      GRADEBOOK_RESPONSES_IN_PROGRESS => t('In progress'),
      GRADEBOOK_RESPONSES_COMPLETED   => t('Completed'),
    );
    if ($which == 'all') {
      $status_string[GRADEBOOK_RESPONSES_GRADED] = t('Graded');
      $status_string[GRADEBOOK_RESPONSES_REDO] = t('Redo');
    }
  }
  return $status_string;
}

/**
 * Prepares extra response fields for the node response forms.
 *
 * @param $node
 *   The response node.
 *
 * @return $form
 *   Additional form array elements for the assignment create form.
 *
 * @ingroup themeable
 */
function gradebook_responses_form_elements($node) {
  $form = array();
  $status_options = _gradebook_responses_status_string('student');
  $locked = (isset($node->rstatus) && $node->rstatus == GRADEBOOK_RESPONSES_GRADED);
  global $user;
  $viewer = user_load(array('uid' => $user->uid));
  $account = user_load(array('uid' => $node->uid));
  // Prepares a list of all possible assignments for this user.
  $options = array('none' => '- ' . t('None') . ' -');
  $vid = gradebookapi_get_vid();
  $result = db_query('SELECT DISTINCT t.tid FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE h.parent = 0 AND t.vid = %d', $vid);
  while ($tid = db_result($result)) {
    $gradebook = gradebookapi_gradebook_load($tid);
    if (gradebookapi_is_teacher($gradebook, $viewer)) {
      $locked = FALSE;
    }
    if (gradebookapi_is_student($gradebook, $account)) {
      $res = gradebookapi_select_nodes($gradebook, array(), 'or', 0, FALSE);
      // Gets the assignments.
      $assignments = array();
      if ($res) {
        while ($assignment = db_fetch_object($res)) {
          $allowed = gradebook_responses_allowed_response_types($assignment->nid);
          if (in_array($node->type, $allowed) && gradebook_responses_user_response_permitted($assignment->nid, $account->uid)) {
            $assignment = node_load($assignment->nid);
            if ($assignment->response_deadline == 1 || (time() < $assignment->due_date)) {
              if ($assignment->max_responses == 0) {
              $remaining_text = t('Unlimited');
              }
              else {
                $count = gradebook_responses_grade_response_number($assignment->nid, $account->uid);
                $remaining = $assignment->max_responses - $count;
                $remaining_text = format_plural($remaining, '1 response', '@count responses') . ' ' . t('remaining');
              }
              $grade_result = db_fetch_array(db_query('SELECT earned, redo FROM {gradebookapi_grade} WHERE uid = %d and nid = %d', $account->uid, $assignment->nid));
              if (is_null($grade_result['earned']) || $grade_result['earned'] == '' || $locked && ($remaining > 0)) {
                // The assignment has not been graded, so add it to the options array.
                $options[$assignment->nid] = $assignment->title . '(' . $remaining_text . ')';
              } 
              else {
                if ($grade_result['redo']) {
                  $options[$assignment->nid] = t('Redo of') . ' ' . $assignment->title;
                }
              }
            }
          }
        }
      }
    }
  }
  $form['gradebook_responses'] = array(
    '#type'        => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed'   => FALSE,
    '#title'       => t('Assignment Response Settings'),
    '#tree'        => FALSE,
    '#weight'      => 0,
  );

  if (isset($_GET['aid'])) {
    $form['gradebook_responses']['aid'] = array('#type' => 'value', '#value' => $_GET['aid']);
  }
  else {
    $form['gradebook_responses']['aid'] = array(
      '#type'          => 'select',
      '#title'         => t('This is a response to assignment'),
      '#default_value' => isset($node->aid) ? $node->aid : NULL,
      '#options'       => $options,
      '#required'      => TRUE,
      '#disabled'      => $locked,
    );
  }

  $form['gradebook_responses']['rstatus'] = array(
    '#type'          => 'select',
    '#title'         => t('Response Status'),
    '#default_value' => isset($node->rstatus) ? $node->rstatus : NULL,
    '#options'       => $status_options,
    '#required'      => TRUE,
    '#disabled'      => $locked,
  );
  return $form;
}

/**
 * Allows teacher to specify the response type for this assignment.
 *
 * @param $node
 *   The assignment node.
 *
 * @return $form
 *   Additional form array elements for the assignment create form.
 *
 * @see gradebook_responses_form_alter().
 */
function gradebook_responses_assignment_form_elements($node) {
  $form = array();
  $types = gradebook_responses_get_response_types();
  $options = array();
  foreach ($types as $type) {
    $options[$type] = $type;
  }

  // Prepares the default values for the select form element.
  $default = array();
  if (isset($node->allowed_response_types)) {
    foreach ($node->allowed_response_types as $type) {
      $default[$type] = $type;
    }
  }

  $form['allowed_response_types'] = array(
    '#type'          => 'select',
    '#title'         => t('Allowed response type'),
    '#default_value' => $default,
    '#options'       => $options,
    '#multiple'      => TRUE,
    '#required'      => FALSE,
    '#description'   => t('Select one or more content types that students can create to respond to the assignment.'),
    '#weight'        => 10,
  );

  $form['max_responses'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Maximum number of responses to allow'),
    '#default_value' => isset($node->max_responses) ? $node->max_responses : 0,
    '#required'      => TRUE,
    '#description'   => t("Enter the number of responses a student can submit for this assignment. Enter '0' for unlimited."),
    '#weight'        => 12,
  );

  $form['response_deadline'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow responses after the assignment due date.'),
    '#default_value' => (isset($node->response_deadline) ? $node->response_deadline : 0),
    '#required' => TRUE,
    '#weight' => 13,
  );

  return $form;
}

/**
 * Implements hook_form_alter().
 */
function gradebook_responses_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'gradebookapi_admin_settings') {
    $form['gradebook_responses_types'] = array(
      '#type'          => 'checkboxes',
      '#title'         => t('Student Response Types'),
      '#multiple'      => TRUE,
      '#default_value' => (array) variable_get('gradebook_responses_types', array()),
      '#options'       => array_map('check_plain', node_get_types('names')),
      '#description'   => t('A list of node types you want to treat as student responses.'),
      '#weight'        => -9,
    );
  }
  if ($form_id == 'gradebook_teacher_settings') {
    // Add options to the local gradebook settings form.
    $gid = $form['#gid'];

    $default = variable_get('gradebook_responses_settings-' . $gid, 0);

    $form['local']['gradebook_responses_settings-'. $gid] = array(
      '#title' => t('Allow student responses after the assignment due date.'),
      '#type' => 'checkbox',
      '#default_value' => $default,
      '#description' => t('Enable this option to allow students to submit responses after the assignment due date. If disabled, student responses will not be accepted after the due date. Note that you an override this default behavior for individual assignments when creating or editing the assignment.'),
      '#required' => TRUE,
    );
  }
  if (isset($form['type']) && $form['type']['#value'] . '_node_form' == $form_id) {
    $node = $form['#node'];
    $types = gradebook_responses_get_response_types();
    if (in_array($node->type, $types)) {
      $form += gradebook_responses_form_elements($node);
    }
    $types = gradebookapi_get_assignment_types();
    if (!empty($types)) {
      if (in_array($node->type, $types)) {
        $form['gradebookapi'] += gradebook_responses_assignment_form_elements($node);
      }
    }
  }
}

/**
 * Implements hook_nodeapi().
 */
function gradebook_responses_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  $types = (array) gradebook_responses_get_response_types();
  if (!empty($types) && in_array($node->type, $types)) {
    switch ($op) {
      case 'load':
        return _gradebook_responses_load($node);
      case 'insert':
        _gradebook_responses_insert($node);
        break;
      case 'update':
        _gradebook_responses_update($node);
        break;
      case 'delete':
        _gradebook_responses_delete($node);
        break;
      case 'view':
        _gradebook_responses_view($node, $teaser, $page);
        break;
    }
  }
  else {
    $types = (array) gradebookapi_get_assignment_types();
    if (in_array($node->type, (array) gradebookapi_get_assignment_types())) {
      switch ($op) {
        case 'load':
          // Retrieves an array of allowed response types for this node.
          $allowed = gradebook_responses_allowed_response_types($node->nid);
          $max_responses = gradebook_responses_assignment_max_responses($node->nid);
          $deadline = db_result(db_query('SELECT response_deadline FROM {gradebookapi_assignment} WHERE nid = %d', $node->nid));
          $additions = array(
            'allowed_response_types' => $allowed,
            'max_responses' => $max_responses,
            'response_deadline' => $deadline,
          );
          return $additions;
        case 'insert':
        case 'update':
          // This should always be called after gradebookapi_nodeapi.
          // Stores allowed response types in the database as an imploded string.
          $allowed = implode(',', $node->allowed_response_types);
          if ($allowed != '') {
            db_query("UPDATE {gradebookapi_assignment} SET response_types = '%s', max_responses = %d WHERE nid = %d", $allowed, $node->max_responses, $node->nid);
          }
          else {
            db_query("UPDATE {gradebookapi_assignment} SET response_types = NULL, max_responses = 0 WHERE nid = %d", $node->nid);
          }
          db_query("UPDATE {gradebookapi_assignment} SET response_deadline = %d WHERE nid = %d", $node->response_deadline, $node->nid);
          break;
        case 'view':
          if (isset($node->max_responses)) {
            $node->content['responses_permitted'] = array(
              '#value' => theme('gradebook_responses_permitted', $node->max_responses),
              '#weight' => -97,
            );
          }
          break;
      }
    }
  }
}

/**
 * Prepares a list of assignment response links for the gradebook grade summary.
 *
 * @param $nid
 *   The assignment node id.
 * @param $uid
 *   The user id.
 *
 * @return
 *   An associative array with keys 'title' and 'links', each holding an
 *   array of response titles and links.
 */
function gradebook_responses_assignment_response($nid, $uid) {
  $responses = gradebook_responses_get_responses(array('aid' => $nid, 'uid' => $uid));
  $status_string = _gradebook_responses_status_string('all');
  $rlinks = array();
  $rtitle = '';
  if ($n = count($responses) > 0) {
    $rtitle = format_plural($n, 'Response', '@count Responses') . ':';
    $i = 0;
    foreach ($responses as $response) {
      $i++;
      $rstatus = $response['rstatus'];
      $rstatustext = $status_string[$rstatus];
      $rlinks[] = l($i . ' (' . $rstatustext . ')', 'node/' . $response['nid']);
    }
  }
  return array('title' => $rtitle, 'links' => $rlinks);
}

/**
 * Updates the response status when a grade is saved.
 *
 * @param $grade
 *   The grade object that is being saved.
 *
 * @return NONE
 */
function gradebook_responses_update_responses($grade) {
  $status_string = _gradebook_responses_status_string();
  $rstatus = GRADEBOOK_RESPONSES_NOT_SET;
  $result = db_query("SELECT COUNT(nid) FROM {gradebook_responses} WHERE uid = %d AND aid = %d", $grade->uid, $grade->nid);
  if (count($result) > 0) {
    if (is_numeric($grade->earned)) {
      $rstatus = ($grade->redo) ? GRADEBOOK_RESPONSES_REDO : GRADEBOOK_RESPONSES_GRADED;
      // A reponse exists and a grade has been assigned.
      db_query("UPDATE {gradebook_responses} SET rstatus = %d WHERE uid = %d AND aid = %d", $rstatus, $grade->uid, $grade->nid);
      db_query("UPDATE {gradebookapi_grade} SET redo = %d WHERE uid = %d AND nid = %d", $grade->redo, $grade->uid, $grade->nid);
      drupal_set_message(t('Changed response status to @status for this assignment.', array('@status' => $status_string[$rstatus])));
    }
    else {
      // Unlock any locked responses that have null earned grade.
      db_query("UPDATE {gradebook_responses} SET rstatus = %d WHERE uid = %d AND aid = %d AND rstatus = %d", GRADEBOOK_RESPONSES_NOT_SET, $grade->uid, $grade->nid, GRADEBOOK_RESPONSES_GRADED);
      db_query("UPDATE {gradebookapi_grade} SET redo = %d WHERE uid = %d AND nid = %d", 0, $grade->uid, $grade->nid);
    }
  }
}

/**
 * Implements hook_gradebook_grade_class().
 *
 * Return a css class name to style the gradebook_grade_page when an
 * assignment response has been submitted.
 *
 * @param $nid
 *   The assignment node id.
 * @param $uid
 *   The user id.
 *
 * @return
 *   A css class name
 */
function gradebook_responses_gradebook_grade_class($nid, $uid) {
  $class = '';
  $responses = array();
  $result = db_query('SELECT rstatus FROM {gradebook_responses} WHERE aid = %d AND uid = %d', $nid, $uid);
  while ($response = db_result($result)) {
   $responses[] = $response;
  }
  $redo = db_result(db_query('SELECT redo FROM {gradebookapi_grade} WHERE uid = %d and nid = %d', $uid, $nid)); 
  if ($redo) {
      $class = 'response redo-grade';
  }
  // Provides css classes according to the highest response level.
  if (in_array((int)GRADEBOOK_RESPONSES_COMPLETED, (array)$responses)) {
    $class = 'response completed';
  }
  elseif (in_array((int)GRADEBOOK_RESPONSES_IN_PROGRESS, (array)$responses)) {
    $class = 'response inprogress';
  }

  return $class;
}

/**
 * Implements hook_gradebook_legend().
 */
function gradebook_responses_gradebook_legend() {
  $empty = variable_get('gradebook_empty_grade', '--');
  $items = array(
    'response redo-grade' => array('item' => t('Redo Assignment'), 'example' => '50'),
    'response completed'  => array('item' => t('Completed Response'), 'example' =>  $empty),
    'response inprogress' => array('item' => t('In Progress Response'), 'example' =>  $empty),
    'response notset'     => array('item' => t('Response Status Not Set'), 'example' =>  $empty),
  );
  return $items;
}

/**
 * Implements hook_gradebookapi_grade().
 */
function gradebook_responses_gradebookapi_grade($action, &$grade) {
  switch($action) {
    case 'set':
      gradebook_responses_update_responses($grade);
      break;
    case 'get':
      $grade->redo = db_result(db_query("SELECT redo FROM {gradebookapi_grade} WHERE nid = %d AND uid = %d", $grade->nid, $grade->uid));
      break;
  }
  return $grade;
}

/**
 * Implements hook_gradebook_form_add_content().
 */
function gradebook_responses_gradebook_form_add_content($position, &$form, $id, $teacher) {
  switch ($position) {
    case 'title':
      return theme('gradebook_responses_gradebook_form_title', $form['grade'][$id]['nid']['#value'], $form['grade'][$id]['uid']['#value']);
  }
}

/**
 * Returns HTML list of responses in the gradebook grade form.
 *
 * @param $nid
 *   The assignment node id.
 * @param $uid
 *   The user id.
 *
 * @return
 *   The HTML string ready to display.
 *
 * @ingroup themeable
 */
function theme_gradebook_responses_gradebook_form_title($nid, $uid) {
  $response = gradebook_responses_assignment_response($nid, $uid);
  $response_output = '';
  if (!empty($response)) {
    $response_output = '<div class = "response-list-block"><p>';
    $response_output .= '<span class = "response-list-title">' . $response['title'] . '</span>';
    $response_output .= '<ul class = "response-list">'; 
    $response_output .= '<li>' . implode('</li><li>', $response['links']) . '</li></ul></p></div>';
  }
  return $response_output;
}

/**
 * Implements hook_gradebook_form_add_elements().
 *
 * Adds a redo permitted check box to the grade edit page.
 */
function gradebook_responses_gradebook_form_add_elements(&$form, &$form_state, $grades, $gradebook) {
  $teacher = gradebookapi_is_teacher($gradebook);
  foreach ($grades as $id => $grade) {
    $form['grade'][$id]['redo'] = array(
      '#type' => 'checkbox',
      '#prefix' => '<div class = "gradebook-responses-redo-box">',
      '#suffix' => '</div>',
    );
    if ($teacher) {
      // If redo is checked when saving a grade it will reset the status of all responses to redo - 
      // indicating the assignment can be redone. To avoid accidently setting this, the default is
      // FALSE. 
      $form['grade'][$id]['redo']['#default_value'] = FALSE;
    }
    else {
      $form['grade'][$id]['redo']['#value'] = isset($grade['redo']) ? $grade['redo'] : FALSE;
      $form['grade'][$id]['redo']['#disabled'] = TRUE;
    }
  }
}

/**
 * Implements hook_gradebook_adjust_grade_form_table().
 */
function gradebook_responses_gradebook_adjust_grade_form_table(&$form, $table) {
  $newheader = $table['header'];
  $lastcolhead = array_pop($newheader);
  $newheader['redo'] = t('Redo Permitted');
  $newheader[] = $lastcolhead;
  $newrows = array();
  foreach ($table['rows'] as $id => $row) {
    $lastcol = array_pop($row['data']);
    $row['data'][] = array('data' => drupal_render($form['grade'][$id]['redo']), 'class' => 'redo-box');
    $row['data'][] = $lastcol;
    $newrows[] = $row;
  }
  return array('header' => $newheader, 'rows' => $newrows);
}
