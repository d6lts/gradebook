<?php
// $Id$
/**
 * @file
 * An API for a simple gradebook.
 */

/**
 * Implementation of hook_perm().
 */
function gradebookapi_perm() {
  return array('admin gradebookapi');
}

/**
 * Implementation of hook_theme().
 */
function gradebookapi_theme() {
  return array(
    'gradebookapi_assignment_possible'  => array('arguments' => array('possible')),
    'gradebookapi_assignment_due_date' => array('arguments' => array('assignment')),
  );
}

/**
 * Implementation of hook_menu().
 */
function gradebookapi_menu() {
  $items = array();

    $items['admin/gradebook'] = array(
      'title'            => 'Gradebook',
      'description'      => 'Administer the suite of Gradebook modules.',
      'position'         => 'left',
      'weight'           => -5,
      'page callback'    => 'system_admin_menu_block_page',
      'access arguments' => array('access administration pages'),
      'file'             => 'system.admin.inc',
      'file path'        => drupal_get_path('module', 'system'),
      );

    $items['admin/gradebook/gradebookapi'] = array(
      'title'            => 'Gradebook API',
      'description'      => 'Provides a gradebook API.',
      'page callback'    => 'drupal_get_form',
      'page arguments'   => array('gradebookapi_admin_settings'),
      'access callback'  => 'user_access',
      'access arguments' => array('administer site configuration'),
      'file'             => 'gradebookapi.admin.inc',
      'type' => MENU_NORMAL_ITEM, // optional
    );
  return $items;
}

/**
 * Implementation of hook_help().
 */
function gradebookapi_help($path, $arg) {
  switch ($path) {
    case 'admin/gradebook/gradebookapi':
      $output = '<p>'. t('The gradebook API provides a framework for developing gradebook user interfaces.') .'</p>';
      $output .= '<p>'. t('Indicate which of the following content types can be used as gradebook assignments. Their create content (add) forms will be given additional fields so the teacher can select the appropriate gradebook and to assign a possible number of points for the assignment.') .'</p>';
      return $output;
    case 'admin/gradebook':
      $output = '<p>'. t('The Gradebook suite of modules provides the framework and user interface for gradebooks that can be used by students and teachers. You can use the links below to configure these modules') .'</p>';
      return $output;
  }
}

/**
 * Implementation of hook_user().
 *
 * @return NONE
 */
function gradebookapi_user($op, &$edit, &$account, $category = NULL) {
  if ($op == 'delete' ) {
    drupal_set_message(t('Deleting gradebook grades for %name (uid %d) since account is being deleted',  array('%name' => $account->name, '%d' => $account->uid)));
    // check to see if $account is a student in each gradebook
    $student_in_any_gradebook = FALSE;
    $vid = gradebookapi_get_vid();
    $result = db_query('SELECT DISTINCT t.tid, FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE h.parent = 0 AND t.vid = %d', $vid);
    while ($tid = db_result($result)) {
      $gradebook = gradebookapi_gradebook_load($tid);
      if (gradebookapi_is_student($gradebook, $account)) {
        $student_in_any_gradebook = TRUE;
        // get assignments
        $assignments = gradebookapi_select_nodes($gradebook, $tids = array());
        foreach ($assignments as $assignment) {
          $files = gradebookapi_attachment_load($assignment->nid, $account->uid);
          foreach ($files as $file) {
            gradebookapi_remove_file($file);  // remove the files attached to this users grades
          }
        }
      }
    }  // now its safe to wipe all grades that might be associated with this account...
    if ($student_in_any_gradebook) {
      db_query("DELETE FROM {gradebookapi_grade} WHERE uid=%d", $account->uid);
      db_query("DELETE FROM {gradebookapi_cache} WHERE uid=%d", $account->uid);
      watchdog('gradebookapi', 'Deleted gradebook grades for %name (uid %d) upon deletion of account.', array('%name' => $account->name, '%d' => $account->uid), WATCHDOG_INFO);
    }
  }
}

/**
 *  gradebookapi_get_assignment_types
 *  @return 
 *    an array of content types that are used as gradebook assigments
 */
function gradebookapi_get_assignment_types() {
  $vid = gradebookapi_get_vid();
  $vocabulary = taxonomy_vocabulary_load($vid); // returns vocabulary object
  return $vocabulary->nodes;
}

/**
 *  gradebookapi_get_vid
 *    retrieves the gradebook taxonomy vocabulary id for gradebook terms (gradebooks and categories),
 *    or creates one if it doesn't exist.
 *  @return 
 *    the taxonomy vocabulary id for the gradebook 
 */
function gradebookapi_get_vid() {
  $vid = variable_get('gradebookapi_nav_vocabulary', '');
  if (empty($vid)) {
    // Check to see if a forum vocabulary exists
    $vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE module = '%s'", 'gradebook'));
    if (!$vid) {
      $edit = array(
        'name' => 'Gradebook',
        'description' => '',
        'help'        => '',
        'multiple' => 0,
        'required' => 1,
        'hierarchy' => 1,
        'relations' => 0,
        'module' => 'gradebook',
        'nodes' => array(),  // does this require an assignment type?
      );
      taxonomy_save_vocabulary($edit);
      $vid = $edit['vid'];
    }
    variable_set('gradebookapi_nav_vocabulary', $vid);
  }
  return $vid;
}

/**
 *  gradebookapi_gradebook_load
 *    retreives the gradebook term
 *  @param $tid
 *    the gradebook term id
 *  @return 
 *    the taxonomy term for the requested gradebook, or FALSE if it doesn't exist
 */
function gradebookapi_gradebook_load($tid) {
  if (_gradebookapi_is_root_term($tid)) {
    return taxonomy_get_term($tid);
  }
  else {
    return FALSE;
  }
}

/** 
 *  Helper function that determines if a term id is the root of the taxonomy tree
 *  @param $tid 
 *    the gradbook (or category) term id
 *  @return 
 *    TRUE if $tid is the root, FALSE if it has parents
 */
function _gradebookapi_is_root_term($tid) {
  $parents = taxonomy_get_parents($tid);
  if (!empty($parents)) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 *  gradebookapi_get-tid_gradebook
 *    get the parent term (gradebook) for a child tid (assignment category)
 *  @param $tid
 *    the $tid for a gradebook category
 *  @return
 *    the parent gradebook (taxonomy term) for the category 
 */
function gradebookapi_get_tid_gradebook($tid) {
  $parents = taxonomy_get_parents_all($tid);
  return array_pop($parents);
}

/**
 *  gradebookapi_select_nodes
 *
 *  Selects all the assignment nodes associated with a set of gradebook term ids. Particularly useful for a
 *  Gradebook page that lists all assignments in a gradebook and their grades
 *  @param $gradebook
 *    the gradebook object 
 *  @param $tids
 *    an array of term ids (gradebook categories) to use in the search. If empty, use all gradebook categories 
 *  @param $operator
 *    Optional: default is 'or' which ... otherwise ...
 *  @param $depth
 *    Optional: if set extend the taxonomy tree accordingly, otherwise include only root terms ? 
 *  @param $pager
 *    Optional: Default is TRUE, perform a paged database query, set to FALSE to do a limited range query instead
 *  @param $order
 *    Optional:  use this to modify the query sort order. The default it Sticky DESC, Created DESC
 *  @return
 *    Database query result
 */
function gradebookapi_select_nodes($gradebook, $tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {
  $vid = gradebookapi_get_vid();
  $tree = taxonomy_get_tree($vid, $gradebook->tid);
  $allowed_tids = array_map('_taxonomy_get_tid_from_term', $tree);
  $allowed_tids[] = $gradebook->tid;
  $use_tids = array();

  if (!count($tids)) {
    // use all tids in gradebook
    $use_tids = $allowed_tids;
  }
  else {
    // make sure tids are only in gradebook
    foreach ($tids as $tid) {
      if (in_array($tid, $allowed_tids)) {
        $use_tids[] = $tid;
      }
    }
  }
//$tids[] = $gradebook->tid; // add in gradebook tid

  // taxonomy_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC')
  return _gradebookapi_select_nodes($use_tids, $operator, $depth, $pager, $order);
}

/**
 *  Helper function to select assignment nodes affiliated with a set of gradebook categories  
 *  @see gradebookapi_select_nodes()
 *  
 */
function _gradebookapi_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {
  if (count($tids) > 0 ) {

    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    foreach ($tids as $index => $tid) {

      if (is_numeric($tid)) {  // guard against null $tids...but what is the source of these?
        $term = taxonomy_get_term($tid);
        $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
        $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
      }
      else {
        unset($tids[$index]); // remove the offending $tid
      }
    }

    if ($operator == 'or') {
      $str_tids = implode(',', call_user_func_array('array_merge', $descendant_tids));
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.nid = tn.nid INNER JOIN {term_data} td ON tn.tid = td.tid INNER JOIN {gradebookapi_assignment} a ON n.nid = a.nid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1 ORDER BY '. $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.nid = tn.nid INNER JOIN {term_data} td ON tn.tid = td.tid INNER JOIN {gradebookapi_assignment} a ON n.nid = a.nid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1';
    }
    else {
      $joins = 'INNER JOIN {gradebookapi_assignment} a ON n.nid = a.nid';
      $wheres = '';
      foreach ($descendant_tids as $index => $tids) {
        $joins .= ' INNER JOIN {term_node} tn'. $index .' ON n.nid = tn'. $index .'.nid INNER JOIN {term_data} td ON tn'. $index .'.tid = td.tid';
        $wheres .= ' AND tn'. $index .'.tid IN ('. implode(',', $tids) .')';
      }
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres .' ORDER BY '. $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres;
    }
    $sql = db_rewrite_sql($sql);
    $sql_count = db_rewrite_sql($sql_count);
    if ($pager) {
      $result = pager_query($sql, variable_get('gradebook_grades_per_page', 10), 0, $sql_count);
    }
    else {
      $result = db_query_range($sql, 0, variable_get('feed_default_items', 25));
    }
  }

  return $result;
}

/**
 * gradebookapi_get_grade
 *
 *  Retrieves the grade for the specified user and assignment. 
 *
 *  @param $uid
 *    the user id to use in the request
 *  @param $nid
 *    the assignment node id to use in the request
 *  @return $grade
 *    the grade object
 *    If more than one grade exists only the last query is returned. 
 *    If a grade has not been entered then a partial grade object with the possible value is returned.
 */
function gradebookapi_get_grade($uid, $nid) {
  $grades = gradebookapi_get_grades(array('uid' => $uid, 'nid' => $nid));
  if (count($grades)) {
    return array_pop($grades);
  }
  // if no grade exists, return grade with possible value
  else {
    $result = db_query(
      'SELECT a.possible, a.due_date, a.publish_date '.
      'FROM {gradebookapi_assignment} a '.
      'WHERE a.nid=%d', $nid);
    $grade = db_fetch_object($result);
    $grade->uid = $uid;
    $grade->nid = $nid;

    return $grade;
  }
}

/**
 *  gradebookapi_get_grades
 *    retrieves grade objects from the gradebookapi_grade and gradebookapi_assignment tables.
 *  @param $param
 *    an array of the form 'field' => $value to be used as the WHERE clause in an SQL query.
 *    Note: fields must be from gradebookapi_grade (uid, nid, earned, exempt, timestamp or note)
 *  @return $grades
 *    an array of grade objects matching the constraint requested through $param.
 */
function gradebookapi_get_grades($param = array()) {
  $grades = array();

  foreach ($param as $key => $value) {
    $cond[] = 'g.'. db_escape_string($key) ." = '%s'";
    $arguments[] = $value;
  }
  $cond = implode(' AND ', $cond);

  $result = db_query('SELECT g.uid, g.nid, g.earned, g.exempt, a.possible, g.timestamp, g.note, a.due_date, a.publish_date FROM {gradebookapi_grade} g INNER JOIN {gradebookapi_assignment} a ON g.nid = a.nid WHERE '. $cond, $arguments);
  while ($grade = db_fetch_object($result)) {

    $grade->files = gradebookapi_attachment_load($grade->nid, $grade->uid);
    $grades[] = $grade;
  }

  return $grades;
}

// if there is a file attached to the grade, load the file object 

function gradebookapi_attachment_load($nid, $uid) {
  $files = array();
  if (isset($nid) && isset($uid)) {  // MGN: check this...
    $result = db_query('SELECT f.fid, f.uid, f.filename, f.filepath, f.filemime, f.filesize, f.status, f.timestamp, g.list, g.description FROM {files} f INNER JOIN {gradebookapi_files} g ON f.fid = g.fid WHERE g.nid = %d AND g.uid = %d ORDER BY f.fid', $nid, $uid);
    while ($file = db_fetch_object($result)) {
      $file->saved = TRUE;
      $files[$file->fid] = $file;
    }
  }
  return $files;
}

/**
 *  gradebookapi_get_term_grade 
 *    retrieves grade information by category and user from the gradebookapi_cache table
 *
 *  @param $uid
 *    The student user id
 *  @param $tid
 *    The grade category term id
 *  @return $grade
 *    A (partial) grade object
 */
function gradebookapi_get_term_grade($uid, $tid) {
  $result = db_query("SELECT uid, tid, earned, possible FROM {gradebookapi_cache} WHERE tid=%d AND uid=%d", $tid, $uid);
  $grade = db_fetch_object($result);

  return $grade;
}

/**
 *  gradebookapi_set_grade().
 *    Updates or inserts the grade information into the gradebookapi_grade table.
 *    The student's grades are then recalculated for each gradebook category.
 *    Also handle new file attachments or file deletions
 *  @param $grade
 *    the grade object 
 *  @ return NONE
 */
function gradebookapi_set_grade($grade) {
  $old = gradebookapi_get_grade($grade->uid, $grade->nid);
  $grade->timestamp = time();
  if ($old->timestamp) {
    db_query("UPDATE {gradebookapi_grade} SET exempt=%d, timestamp=%d, note='%s' WHERE uid=%d AND nid=%d", $grade->exempt, $grade->timestamp, $grade->note, $grade->uid, $grade->nid);
  } 
  else {
    db_query("INSERT INTO {gradebookapi_grade} (uid, nid, exempt, timestamp, note) VALUES (%d, %d, %d, %d, '%s')", $grade->uid, $grade->nid, $grade->exempt, $grade->timestamp, $grade->note);
  }

  if (is_numeric($grade->earned)) {  // trying to restore null status, rather than 0.
    db_query("UPDATE {gradebookapi_grade} SET earned = %d WHERE uid=%d AND nid=%d", $grade->earned, $grade->uid, $grade->nid);
  } 
  else {  // allow a grade to be returned to null status
    db_query("UPDATE {gradebookapi_grade} SET earned = NULL WHERE uid=%d AND nid=%d", $grade->uid, $grade->nid);
  }

  gradebookapi_manage_attachments($grade);
  $node = node_load($grade->nid);
  $terms = taxonomy_node_get_terms_by_vocabulary($node, gradebookapi_get_vid());
  foreach ($terms as $term) {
    gradebookapi_calc_grades($grade->uid, $term->tid);
  }
}

  // manage files that have been attached

function gradebookapi_manage_attachments($grade) {
  $attachments = $grade->attachments;
  if (!empty($attachments['files']) || is_array($attachments['files'])) {
    foreach ($attachments['files'] as $fid => $file) {
      $file = (object)$file; // Convert file to object for compatibility
      if (!empty($file->remove)) { // Remove file. Process removals first.
        gradebookapi_remove_file($file);
        unset($attachments['files'][$fid]); 
      }
      if (isset($file->saved) && $file->saved) {  // Add entry in {gradebookapi_files} table
        drupal_set_message('Updating settings of attached file.');
        db_query("UPDATE {gradebookapi_files} SET list=%d, description='%s' WHERE fid=%d", $file->list, $file->description, $fid);
      } 
      else {
        drupal_set_message('Adding new file and setting status.');
        db_query("INSERT INTO {gradebookapi_files} (uid, nid, fid, list, description) VALUES (%d, %d, %d, %d, '%s')", $grade->uid, $grade->nid, $fid, $file->list, $file->description);
        file_set_status($file, FILE_STATUS_PERMANENT);
      }
    }
  }
}

function gradebookapi_remove_file($file) {
  if (isset($file->fid)) {
    db_query('DELETE FROM {gradebookapi_files} WHERE fid=%d', $file->fid);
    // If the file isn't used by any other grades delete it.
    $count = db_result(db_query('SELECT COUNT(fid) FROM {gradebookapi_files} WHERE fid=%d', $file->fid));
    if ($count < 1) {
      file_delete($file->filepath);
      db_query('DELETE FROM {files} WHERE fid=%d', $file->fid);
    }
  }
}

/**
 *  gradebookapi_rebuild_grades().
 *    Recursively re-calculates grades for each gradebook category and its children.
 *  @param $tid
 *    the gradebook category term id  (parent or child) 
 *  @ return NONE
 */
function gradebookapi_rebuild_grades($tid) {
  $children = taxonomy_get_children($tid, gradebookapi_get_vid());
  if ($children) {
    foreach ($children as $child) {
      gradebookapi_rebuild_grades($child->tid);
    }
  }
  else {
    gradebookapi_calc_term_grades($tid);
  }
}

/**
 *  gradebookapi_clear_term_grades().
 *    Deletes term grades from the gradebookapi_cache table.
 *  @param $tid
 *    The gradebook category term id  (parent or child) 
 *  @param $recursive
 *    If TRUE, then all child term grades are also deleted.
 *  @param $start
 *    if TRUE, then term grades will be recalculated.
 *  @return NONE
 */
function gradebookapi_clear_term_grades($tid, $recursive=TRUE, $start=TRUE) {
  db_query("DELETE FROM {gradebookapi_cache} WHERE tid=%d", $tid);
  // do a recursive delete?
  if ($recursive) {
    $children = taxonomy_get_children($tid, gradebookapi_get_vid());
    foreach ($children as $child) {
      gradebookapi_clear_term_grades($child->tid, $recursive, FALSE);
    }
  }
  // tell parents to recalc cache
  if ($start) {
    $parents = taxonomy_get_parents($tid);
    foreach ($parents as $parent) {
      gradebookapi_calc_term_grades($parent->tid);
    }
  }
}

/**
 *  gradebookapi_calc_grades().
 *    Calculates the student grade for a given gradebook category.
 *  @param $tid
 *    The gradebook category term id  (parent or child) 
 *  @param $uid
 *    The student user id, if its < 1, then all grades are calculated.
 *  @param $recursive
 *    If TRUE, then calc grades for all gradebook category child terms. 
 *  @return NONE
 */
function gradebookapi_calc_grades($uid, $tid, $recursive=TRUE) {
  $earned = 0;
  $possible = 0;

  $gradebook = gradebookapi_get_tid_gradebook($tid);
  //watchdog('gradebook', "_gradebook_calc_grades($uid, $tid, $recursive)");
  //print_r(debug_backtrace());

  // if UID is < 1, calc grades for ALL users
  if ($uid<=0) {
    return gradebookapi_calc_term_grades($tid);
  }
  else {
    // clear cache
    db_query("DELETE FROM {gradebookapi_cache} WHERE tid=%d AND uid=%d", $tid, $uid);

    // get grades from child terms
    $children = taxonomy_get_children($tid, gradebookapi_get_vid());
    foreach ($children as $child) {
      $grade = gradebookapi_get_term_grade($uid, $child->tid);
      if ($grade && !is_null($grade->earned) &&  !$grade->exempt) {
        $earned += $grade->earned;
        $possible += $grade->possible;
      }
    }

    // get grades from nodes at this term
    $result = gradebookapi_select_nodes($gradebook, array($tid), 'or', 0, FALSE);
    while ($assignment = db_fetch_object($result)) {
      $grade = gradebookapi_get_grade($uid, $assignment->nid);
      //print_r($grade);
      if ($grade && !is_null($grade->earned) && !$grade->exempt) {
        $earned += $grade->earned;
        $possible += $grade->possible;
      }
    }

    // cache grade
    db_query("INSERT INTO {gradebookapi_cache} (uid, tid, earned, possible) VALUES (%d, %d, %d, %d)", $uid, $tid, $earned, $possible);

    if ($recursive) {
      // recalc parents
      $parents = taxonomy_get_parents($tid);
      foreach ($parents as $parent) {
        gradebookapi_calc_grades($uid, $parent->tid, $recursive);
      }
    }
  }
}

/**
 *  gradebookapi_calc_term_grades().
 *  Calculate all student grades for a gradebook or gradebook category.
 *
 *  @param $tid
 *    the taxonomy term id to use to lookup grades on associated assignment nodes
 *  @param $recursive
 *    If TRUE (default), then all gradebook category child terms are also calculated.
 *  @return
 *    NULL - no return value
 */
function gradebookapi_calc_term_grades($tid, $recursive=TRUE) {
  $gradebook = gradebookapi_get_tid_gradebook($tid);
  $students = gradebookapi_get_students($gradebook);
  if ( $str_uids = implode(',', $students) ) {
    $result = db_query("SELECT u.uid FROM {users} u WHERE u.status <> 0 AND u.uid IN (". $str_uids .") ORDER BY u.name ASC");
  }
  else {
    $result = FALSE;
  }
  if ($result) {
    while ($account = db_fetch_object($result)) {
      gradebookapi_calc_grades($account->uid, $tid, $recursive);
    }
  }
}

/**
 *  gradebookapi_calc_assignment_grades().
 *    Calculates the student grades for a given set of gradebook categories associcated with an assignment.
 *  @param $node
 *    The assignment node 
 *  @param $terms
 *    An array of gradebook category terms to calculate the grade for.
 *    If empty, then grades will be calculated for all categories.
 *  @return NONE
 */
function gradebookapi_calc_assignment_grades($node, $terms = array()) {

  if (empty($terms)) {
    $terms = taxonomy_node_get_terms_by_vocabulary($node, gradebookapi_get_vid());
  }

  foreach ($terms as $term) {
    gradebookapi_calc_term_grades($term->tid);
  }
}

/**
 * Implementation of hook_taxonomy().
 *
 * @return NONE
 */
function gradebookapi_taxonomy($op, $type, $obj = NULL) {
  if ($obj['vid'] == gradebookapi_get_vid()) {
    switch ($op) {
      case 'insert':
      case 'update':
        switch ($type) {
          case 'term':
            // TODO: can this code be removed?
            // update grade cache
            //if ($obj['parent_old'] && ($obj['parent_old'] != $obj['parent'])) {
              // update old parent, but exclude 'tid' as hierarchy is not updated yet
              //gradebookapi_calc_term_grades($obj['parent_old'], array('tid'=>array($obj['tid'])));
            //}
            //gradebookapi_calc_term_grades($obj['tid']);

            // at this point, the term has been saved, but the hierarchy table has not been updated
            // delete the term grades from cache and force cleaning up OLD tree branch
            //gradebookapi_clear_term_grades($obj['tid']);
            // update new parent, forcing inclusion of 'tid'
            //gradebookapi_calc_term_grades($obj['tid'], array('parents'=>array($obj['parent'])), array('parents'=>array($obj['parent_old'])));

            // recalc old parent, excluding current 'tid'
            //if ($obj['parent_old']) {
            //  gradebookapi_calc_term_grades($obj['parent_old'], array('children'=>array($obj['tid'])));
            //}
            // recalc new parent, including current 'tid' and excluding old parent
            //gradebookapi_calc_term_grades($obj['parent'][0], array('parents'=>array($obj['parent_old'])), array('children'=>array($obj['tid'])));
            break;
        }
        break;
      case 'delete':
        switch ($type) {
          case 'term':
            // TODO: by the time we get here, the hierarchy has already been cleaned.
            //       how do we tell the parent to recalc?
            gradebookapi_clear_term_grades($obj['tid']);
            // TODO: delete nodes associated with this term and it's children
            break;
          case 'vocabulary':
            variable_del('gradebookapi_nav_vocabulary');
            break;
        }
        break;
    }
  }
}

/**
 *  gradebookapi_assigment_terms().
 *    get all of the gradebook taxonomy terms associated with a node
 *  @param $node
 *    the assignment node
 *  @return
 *    an array of gradebook taxonomy terms
 */
function gradebookapi_assignment_terms($node) {
  $terms = array();
  $vid = gradebookapi_get_vid();
  $allterms = taxonomy_node_get_terms($node);

  foreach ($allterms as $term) {
    // make sure we only look in the gradebook vocabulary
    if ($term->vid == $vid) {
      $terms[] = $term;
    }
  }

  return $terms;
}

/**
 *  gradebookapi_assigment_load().
 *    Retrieve the additional form fields from the gradebookapi_assignment database table.
 *    These fields will be added to assignment create node form.
 *    Called via hook_nodeapi (load).
 *  @param $node
 *    the assignment node
 *  @return
 *    an array of form default values
 */
function gradebookapi_assignment_load($node) {
  $additions = db_fetch_array(db_query('SELECT possible, publish_date, due_date FROM {gradebookapi_assignment} WHERE nid = %d', $node->nid));
  return $additions;
}

/**
 *  gradebookapi_assigment_insert().
 *    Insert additional assignment fields into the gradebookapi_assignment database table.
 *    The grades are then recalculated since the possible value, etc. may have changed.
 *    Called via hook_nodeapi (insert).
 *  @param $node
 *    the assignment node
 *  @return NONE
 */
function gradebookapi_assignment_insert($node) {
  $node->publish_date = _gradebookapi_drupaldate2unixtime($node->publish_date);
  $node->due_date = _gradebookapi_drupaldate2unixtime($node->due_date);

  $now = time();
  if ($now > $node->publish_date) {
    $node->status = 1;
  }
  else {
    $node->status = 0;
  }

  db_query("INSERT INTO {gradebookapi_assignment} (nid, possible, publish_date, due_date) VALUES (%d, %d, '%d', '%d')", $node->nid, $node->possible, $node->publish_date, $node->due_date);

  // we have to manually update terms as we can't control module order

  taxonomy_node_save($node, $node->taxonomy);

  gradebookapi_calc_assignment_grades($node);
}

/**
 *  gradebookapi_assigment_update().
 *    Update additional assignment fields in the gradebookapi_assignment database table when the node is updated.
 *    The grades are then recalculated since the possible value, etc. may have changed.
 *    Called via hook_nodeapi (update).
 *  @param $node
 *    the assignment node
 *  @return NONE
 */
function gradebookapi_assignment_update(&$node) {
  $node->publish_date = _gradebookapi_drupaldate2unixtime($node->publish_date);
  $node->due_date = _gradebookapi_drupaldate2unixtime($node->due_date);

  if (db_result(db_query('SELECT * FROM {gradebookapi_assignment} a WHERE a.nid = %d', $node->nid))) {
    db_query("UPDATE {gradebookapi_assignment} SET possible = '%s', publish_date = '%d', due_date = '%d'  WHERE nid = %d", $node->possible, $node->publish_date, $node->due_date, $node->nid); 
  }
  else { // assignment doesn't exist in gradebookapi_assignment table, so insert it
    gradebookapi_assignment_insert($node);
  }

  // we have to manually update terms as we can't control module order

  taxonomy_node_save($node, $node->taxonomy);

  gradebookapi_calc_assignment_grades($node);

  //if the term has changed, clear the term grade for the previous term

  $tax = $node->taxonomy;
  $index = gradebookapi_get_vid();
  if (isset($node->oldtid) && isset($tax[$index]) && $tax[$index] != $node->oldtid ) {
      gradebookapi_calc_term_grades($node->oldtid);
  }
}

/**
 *  gradebookapi_assigment_delete().
 *    Delete assignment field values from the gradebookapi_assignment database table when the node is deleted.
 *    The grades are then recalculated.
 *    Called via hook_nodeapi (delete).
 *  @param $node
 *    the assignment node
 *  @return
 *    NONE
 */
function gradebookapi_assignment_delete($node) {
  // delete records for all students for this assignment node
  db_query('DELETE FROM {gradebookapi_assignment} WHERE nid = %d', $node->nid);
  // delete grades for all users for this assignment node
  db_query('DELETE FROM {gradebookapi_grade} WHERE nid = %d', $node->nid);

  // delete any file records attached to grades for this assignment node
  $result = db_query('SELECT fid FROM {gradebookapi_files} WHERE nid=%d', $node->nid);
  while ($fid = db_result($result)) {
    db_query('DELETE FROM {gradebookapi_files} WHERE nid = %d AND fid = %d', $node->nid, $fid);
    // If the file isn't used by any other grades delete the actual file
    $count = db_result(db_query('SELECT COUNT(fid) FROM {gradebookapi_files} WHERE fid=%d', $fid));
    if ($count < 1) { // its not used by any other grades
      $path = db_result(db_query('SELECT filepath FROM {files} WHERE fid=%d', $fid));
      file_delete($path);
      db_query('DELETE FROM {files} WHERE fid=%d', $fid);  // now delete it from the {files} table
    } // it is being used...don't delete it.
  }

  // If taxonomy_node_delete has already been called, then we loose the info in
  // {term_node} needed to recalculate the grade instead, gather the gradebook api
  // terms associated with an assignment and send them into gradebookapi_calc_grades
  // to bypass the call to taxonomy_node_get_terms_by_vocabulary() (which will fail).
  $allterms = $node->taxonomy;
  $vid = gradebookapi_get_vid();
  $terms= array();
  foreach ($allterms as $term) {
    if ($term->vid == $vid) {
      $terms[$term->tid]=$term;
    }
  }
  gradebookapi_calc_assignment_grades($node, $terms);
}

/**
 *  gradebookapi_assigment_view().
 *    Add assignment field values to $node->content before rendering.
 *    Called via hook_nodeapi (view).
 *  @param $node
 *    the assignment node
 *  @param $teaser
 *    the teaser parameter passed from node_view() 
 *  @param $page
 *    the page parameter passed from node_view()
 *  @return NONE
 */
function gradebookapi_assignment_view(&$node, $teaser = FALSE, $page = FALSE) {
  $node = node_prepare($node, $teaser);
  $node->content['possible'] = array(
    '#value' => theme('gradebookapi_assignment_possible', $node->possible),
    '#weight' => -100,
  );
  $node->content['due_date'] = array(
    '#value' => theme('gradebookapi_assignment_due_date', $node->due_date),
    '#weight' => -100,
  );

  // TODO: Check to see if user has a note or attached file in the gradebook for this
  // assignment and provide a note for them so they can go and retrieve it.

  return $node;
}

/**
 *  Theme the assignment_possible field
 * 
 *  @param $possible
 *    The possible number of points for the assignment
 *  @return
 *    The HTML string ready to display
 */
function theme_gradebookapi_assignment_possible($possible) {
  $output = '<div class="gradebook-assignment-possible">'. t('Possible') .': ';
  $output .= '<span class="gradebook-assignment-possible-points">'. $possible .'</span>';
  $output .= '</div>';
  return $output;
}

/**
 *  gradebookapi_assigment_form_elements().
 *    Prepare extra assignment fields for the node create forms.
 *    Called via hook_form_alter.
 *  @param $node
 *    the assignment node
 *  @return $form
 *    additional form array elements for the assignment create form.
 */
function gradebookapi_assignment_form_elements($node) {
  $form = array();

  $form['gradebookapi'] = array(
    '#type' => 'fieldset',
    '#title' => t('Assignment Settings'),
    '#tree' => FALSE,
    '#weight' => 0,
    //'#validate' => array('gradebookapi_assignment_validate' => array()),
  );
  $form['gradebookapi']['possible'] = array(
    '#type' => 'textfield',
    '#title' => t('Possible'),
    '#default_value' => ($node->possible ? $node->possible:'0'),
    '#size' => 10,
    '#maxlength' => 10,
    '#required' => TRUE,
  );

  if ($node->due_date == NULL) {
    $node->due_date = strtotime(variable_get('gradebookapi_assignments_interval', '+1 month'));
  }

  if ($node->publish_date == NULL) {
    $node->publish_date = time();
  }

  $form['gradebookapi']['dates'] = array(
    '#type' => 'fieldset',
    '#collapsible' => FALSE,
    '#title' => t('Assignment dates'),
    '#weight' => -8,
    );

  $form['gradebookapi']['dates']['due_date'] = array(
    '#prefix' => '<div class="date_widget">',
    '#suffix' => '</div>',
    '#type' => 'date',
    '#title' => t('Assignment due date'),
    '#default_value' => is_array($node->due_date) ? $node->due_date : _gradebookapi_unixtime2drupaldate($node->due_date),
    );

  $form['gradebookapi']['dates']['publish_date'] = array(
    '#prefix' => '<div class="date_widget">',
    '#suffix' => '</div>',    
    '#type' => 'date',
    '#title' => t('Publish date'),
    '#default_value' => is_array($node->publish_date) ? $node->publish_date : _gradebookapi_unixtime2drupaldate($node->publish_date),
    );
  $form['#submit'][] = 'gradebookapi_assignment_submit';

  $oldtax = $node->taxonomy;
  if (is_array($oldtax)) {  // an array of terms
    $vid = gradebookapi_get_vid();
    foreach ($oldtax as $term) {
      if ($term->vid == $vid) {  // find the gradebook term
        $oldtid = $term->tid;
      }
    }
  }
  if (isset($oldtid)) {
    $form['gradebookapi']['oldtid'] = array('#type' => 'hidden', '#value' => $oldtid);
  }

  return $form;
}

/**
 *  Implementation of hook_validate().
 *    Verify the form elements have acceptable values.
 *  @param $node
 *    the assignment node
 *  @param $form
 *    the $form parameter passed from node_validate
 *  @return NONE
 */
function gradebookapi_assignment_validate($node, $form = NULL) {
  if ($node) {
    // safe int check
    if (is_numeric($node->possible) ? intval($node->possible) != $node->possible : TRUE) {
      form_set_error('possible', t('The possible value for the assignment must be an integer.'));
    }
    $due_date = _gradebookapi_drupaldate2unixtime($node->due_date);
    $publish_date = _gradebookapi_drupaldate2unixtime($node->publish_date);
    if ($publish_date >= $due_date) {
      form_set_error('publish_date', t('The publish date of an assignment must be before its due date.'));
    }
  }
}

/**
 * Implementation of hook_submit().
 * This checks if the assignment should be marked as published.
 */
function gradebookapi_assignment_submit($form, &$form_state) {

  $publish_date = _gradebookapi_drupaldate2unixtime($form_state['values']['publish_date']);
  $due_date = _gradebookapi_drupaldate2unixtime($form_state['values']['due_date']);

  $now = time();

  $form_state['values']['status'] = ($now >= $publish_date);
  if ($form_state['values']['status']) {
    drupal_set_message(t('The assignment is currently active.'));
  }
  else {
    drupal_set_message(t('The assignment will become active on !date.', array('!date' => format_date($publish_date, 'small'))));
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * @return NONE
 */
function gradebookapi_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type']) && $form['type']['#value'] .'_node_form' == $form_id) {

//    print_r($form);
    $node = $form['#node'];
    $types = gradebookapi_get_assignment_types();

    // are we an assignment type?
    if (!empty($types)) {
      if (in_array($node->type, $types)) {
        $form = array_merge($form, gradebookapi_assignment_form_elements($node));
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 *
 * @return NONE
 */
function gradebookapi_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if (in_array($node->type, (array)gradebookapi_get_assignment_types())) {
    switch ($op) {
      case 'load':
        return gradebookapi_assignment_load($node);
      case 'insert':
        gradebookapi_assignment_insert($node);
        break;
      case 'update':
        gradebookapi_assignment_update($node);
        break;
      case 'delete':
        gradebookapi_assignment_delete($node);
        break;
      case 'view':
        gradebookapi_assignment_view($node, $a3, $a4);
        break;
      case 'validate':
        gradebookapi_assignment_validate($node, $a3);
        break;
    }
  }
}

/**
 *  gradebookapi_is_student_or_teacher().
 *    Determine whether a user is either a student or teacher for a given gradebook
 *    Used to control access to gradebook content
 *  @param $gradebook
 *    the gradebook object
 *  @param $account
 *    the user object
 *  @return
 *    TRUE if $account is a student, teacher or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_student_or_teacher($gradebook, $account = NULL) {

  if (gradebookapi_is_student($gradebook, $account)) {
    return TRUE;
  }
  elseif (gradebookapi_is_teacher($gradebook, $account)) {
    return TRUE;
  }

  return FALSE;

}

/**
 *  gradebookapi_is_student().
 *    Determine whether a user is a student for a given gradebook
 *    Used to control access to gradebook content
 *  @param $gradebook
 *    the gradebook object
 *  @param $account
 *    the user object
 *  @return
 *    TRUE if $account is a student or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_student($gradebook, $account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = user_load(array('uid' => $user->uid));
  }

  // User #1 has all privileges:
  if ($account->uid == 1) {
    return TRUE;
  }

  $students = gradebookapi_get_students($gradebook);
  if (in_array($account->uid, $students)) {
    return TRUE;
  }

  return FALSE;
}

/**
 *  gradebookapi_is_teacher().
 *    Determine whether a user is a teacher for a given gradebook
 *    Used to control access to gradebook content
 *  @param $gradebook
 *    the gradebook object
 *  @param $account
 *    the user object
 *  @return
 *    TRUE if $account is a teacher or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_teacher($gradebook, $account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = user_load(array('uid' => $user->uid));
  }

  // User #1 has all privileges:
  if ($account->uid == 1) {
    return TRUE;
  }

  $teachers = gradebookapi_get_teachers($gradebook);
  if (in_array($account->uid, $teachers)) {
    return TRUE;
  }

  return FALSE;
}

/**
 *  gradebookapi_get_students().
 *    Gradebook UI modules determine which users are students and teachers.
 *    This is done by defining a function hook_gradebookapi_students that returns an array of user ids.
 *    The api calls all of these hook functions and merges the results into one array.
 *  @param $gradebook
 *    the gradebook object
 *  @return
 *    an array of student user ids.
 */
function gradebookapi_get_students($gradebook) {
  return module_invoke_all('gradebookapi_students', $gradebook);
}

/**
 *  gradebookapi_get_teachers().
 *    Gradebook UI modules determine which users are teachers.
 *    This is done by defining a function hook_gradebookapi_teachers that returns an array of user ids.
 *    The api calls all of these hook functions and merges the results into one array.
 *  @param $gradebook
 *    the gradebook object
 *  @return
 *    an array of teacher user ids.
 */
function gradebookapi_get_teachers($gradebook) {
  return module_invoke_all('gradebookapi_teachers', $gradebook);
}

/**
 *  These date functions are copied and adapted from the announcements module
 *  TODO: document these functions
 */


/**
 * Implementation of hook_cron().
 *
 * This function allows gradebookapi to insert its own actions when
 * the cron.php script is run Â– usually by the system cron system. This is useful
 * when performing periodic asynchronous tasks like, as in this case, checking to
 * see if any assignments should be published.
 *
 * @return
 *   Nothing.
 *
 * More detail at @link http://api.drupal.org/api/HEAD/function/hook_cron API page @endlink .
 */
function gradebookapi_cron() {
  $types = (array)gradebookapi_get_assignment_types();

  // Mark ready assignments as published.
  $sql = "UPDATE {node} SET status = 1 WHERE type IN ( '". implode("', '", $types) ."') AND status = 0 AND nid IN (SELECT nid FROM {gradebookapi_assignment} WHERE publish_date <= %d)";
  $the_time = time();
  $query_result = db_query($sql, $the_time);
  //watchdog('gradebookapi', 'Checking assignment status using %sql at timestamp %time, returned %res.', array('%res' => $query_result, '%time' => $the_time, '%sql' => $sql), WATCHDOG_INFO);

}


/**
 *
 */
function _gradebookapi_assignment_status(&$node) {
  $node->publish_date = _gradebookapi_drupaldate2unixtime($node->publish_date);
  $node->due_date = _gradebookapi_drupaldate2unixtime($node->due_date);

  $now = time();
  if ($now > $node->publish_date) {
    $node->status = 1;
  }
  else {
    $node->status = 0;
  }
}

function _gradebookapi_get_timezone() {
  global $user;
  if (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {
    // User has his/her own timezone, use that.
    return $user->timezone;
  }
  return variable_get('date_default_timezone', 0);
}

function _gradebookapi_drupaldate2unixtime($drupal_date) {
  // Compute the time in UTC (GMT).
  $tz_seconds = _gradebookapi_get_timezone();
  return gmmktime(0, 0, 0, (int)$drupal_date["month"], (int)$drupal_date["day"], (int)$drupal_date["year"]) - $tz_seconds;
}

function _gradebookapi_unixtime2drupaldate($unixtime) {
  $unixtime -= _gradebookapi_get_timezone;
  return array('day' => gmdate('j', $unixtime),
    'month' => gmdate('n', $unixtime),
    'year' => gmdate('Y', $unixtime));
}

/**
 * Theme the assignment due date.
 *
 * @param $due_date
 *   The date array.
 *
 * @return
 *   The HTML string ready to display/
 */
function theme_gradebookapi_assignment_due_date($due_date) {
  $output = '<div class="gradebook-assignment-due">'. t('Assignment is due on') .' ';
  $output .= '<span class="gradebook-assignment-due-date">'. format_date($due_date, 'custom', 'F j, Y') .'</span>';
  $output .= '</div>';
  return $output;
}
